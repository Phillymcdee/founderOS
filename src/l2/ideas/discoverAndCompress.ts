import { prisma } from '@/l0/db';
import { logEvent } from '@/l0/events';
import { runSignalIngestionAgent } from '@/l1/ideas/signalIngestion';
import { runProblemMapperAgent } from '@/l1/ideas/problemMapper';
import { getIdeaFilters } from '@/l3/ideasIntent';

export async function runWeeklyDiscoverAndCompressFlow(tenantId: string) {
  const flowInstanceId = `ideas-discover-${Date.now()}`;
  const filtersResponse = await getIdeaFilters(tenantId);

  await logEvent({
    tenantId,
    type: 'FLOW_STARTED',
    flowInstanceId,
    payload: {
      flow: 'weeklyDiscoverAndCompress',
      ideaIntentVersion: filtersResponse.version
    }
  });

  const ingestedSignals = await runSignalIngestionAgent({ tenantId });

  const recentSignals = await prisma.ideaSignal.findMany({
    where: { tenantId },
    orderBy: { createdAt: 'desc' },
    take: 50
  });

  const candidates = runProblemMapperAgent({
    signals: recentSignals,
    filters: filtersResponse.filters
  });

  const createdIdeas = [];

  for (const candidate of candidates) {
    const existing = await prisma.idea.findFirst({
      where: {
        tenantId,
        title: candidate.title
      }
    });

    if (existing) continue;

    const idea = await prisma.idea.create({
      data: {
        tenantId,
        title: candidate.title,
        description: candidate.description,
        icpDescription: candidate.icpDescription,
        arpuEstimate: candidate.arpuEstimate,
        state: 'PENDING_REVIEW',
        autoGenerated: true,
        sourceSignalIds: candidate.sourceSignalIds
      }
    });

    createdIdeas.push(idea);

    await logEvent({
      tenantId,
      type: 'IDEA_AUTO_CREATED',
      primaryEntityId: idea.id,
      payload: {
        sourceSignalIds: candidate.sourceSignalIds,
        ideaIntentVersion: filtersResponse.version
      }
    });
  }

  await logEvent({
    tenantId,
    type: 'FLOW_COMPLETED',
    flowInstanceId,
    payload: {
      flow: 'weeklyDiscoverAndCompress',
      ideaIntentVersion: filtersResponse.version,
      ingestedSignalCount: ingestedSignals.length,
      createdIdeaCount: createdIdeas.length
    }
  });

  return {
    ingestedSignals,
    createdIdeas
  };
}

