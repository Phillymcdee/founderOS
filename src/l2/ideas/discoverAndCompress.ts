import { prisma } from '@/l0/db';
import { logEvent } from '@/l0/events';
import { runSignalIngestionAgent } from '@/l1/ideas/signalIngestion';
import { runProblemMapperAgent } from '@/l1/ideas/problemMapper';
import { getIdeaIntent } from '@/l3/ideasIntent';
import {
  draftTransformationStatement,
  runHardFilters,
  scoreIdea
} from '@/l1/ideas/ideaScoring';

export async function runWeeklyDiscoverAndCompressFlow(tenantId: string) {
  const flowInstanceId = `ideas-discover-${Date.now()}`;
  const ideaIntent = await getIdeaIntent(tenantId);

  await logEvent({
    tenantId,
    type: 'FLOW_STARTED',
    flowInstanceId,
    payload: {
      flow: 'weeklyDiscoverAndCompress',
      ideaIntentVersion: ideaIntent.version
    }
  });

  const ingestedSignals = await runSignalIngestionAgent({
    tenantId,
    sources: ideaIntent.sources
  });

  const recentSignals = await prisma.ideaSignal.findMany({
    where: { tenantId },
    orderBy: { createdAt: 'desc' },
    take: 50
  });

  const candidates = await runProblemMapperAgent({
    signals: recentSignals,
    filters: ideaIntent.filters,
    useLLM: false // Set to true when LLM is configured
  });

  const createdIdeas = [];

  for (const candidate of candidates) {
    const existing = await prisma.idea.findFirst({
      where: {
        tenantId,
        title: candidate.title
      }
    });

    if (existing) continue;

    // Auto-score the idea immediately
    const transformation = draftTransformationStatement({
      title: candidate.title,
      description: candidate.description,
      icpDescription: candidate.icpDescription
    } as any);

    const hardFilters = runHardFilters(
      {
        title: candidate.title,
        description: candidate.description,
        icpDescription: candidate.icpDescription,
        arpuEstimate: candidate.arpuEstimate,
        regulatedConcern: false,
        manualWorkHeavy: false,
        founderFitSignal: true
      } as any,
      ideaIntent.filters
    );

    const passesAll = Object.values(hardFilters).every(Boolean);
    let scores = {
      painFrequencyScore: 1,
      agentLeverageScore: 1,
      dataSurfaceScore: 1,
      repeatabilityScore: 1,
      totalScore: 4
    };

    if (passesAll) {
      scores = scoreIdea(
        {
          title: candidate.title,
          description: candidate.description,
          icpDescription: candidate.icpDescription
        } as any,
        ideaIntent.filters
      );
    }

    const initialState =
      !passesAll
        ? 'KILLED'
        : scores.totalScore >= ideaIntent.filters.minScoreForExperiment
          ? 'EXPERIMENTING'
          : 'SCORING';

    const idea = await prisma.idea.create({
      data: {
        tenantId,
        title: candidate.title,
        description: candidate.description,
        icpDescription: candidate.icpDescription,
        arpuEstimate: candidate.arpuEstimate,
        transformation,
        state: initialState,
        autoGenerated: true,
        sourceSignalIds: candidate.sourceSignalIds,
        ...hardFilters,
        ...scores
      }
    });

    createdIdeas.push(idea);

    await logEvent({
      tenantId,
      type: 'IDEA_AUTO_CREATED',
      primaryEntityId: idea.id,
      payload: {
        sourceSignalIds: candidate.sourceSignalIds,
        ideaIntentVersion: ideaIntent.version
      }
    });
  }

  await logEvent({
    tenantId,
    type: 'FLOW_COMPLETED',
    flowInstanceId,
    payload: {
      flow: 'weeklyDiscoverAndCompress',
      ideaIntentVersion: ideaIntent.version,
      ingestedSignalCount: ingestedSignals.length,
      createdIdeaCount: createdIdeas.length
    }
  });

  return {
    ingestedSignals,
    createdIdeas
  };
}
