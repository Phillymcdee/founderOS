import { prisma } from '@/l0/db';
import { logEvent } from '@/l0/events';
import { runSignalIngestionAgent } from '@/l1/ideas/signalIngestion';
import { runProblemMapperAgent } from '@/l1/ideas/problemMapper';
import { runArchetypeScorerAgent } from '@/l1/ideas/archetypeScorer';
import { getIdeaIntent } from '@/l3/ideasIntent';
import type { ArchetypeFramework } from '@/l3/archetypeFramework';
import {
  draftTransformationStatement,
  runHardFilters,
  scoreIdea
} from '@/l1/ideas/ideaScoring';

export async function runWeeklyDiscoverAndCompressFlow(tenantId: string) {
  const flowInstanceId = `ideas-discover-${Date.now()}`;
  const ideaIntent = await getIdeaIntent(tenantId);

  await logEvent({
    tenantId,
    type: 'FLOW_STARTED',
    flowInstanceId,
    payload: {
      flow: 'weeklyDiscoverAndCompress',
      ideaIntentVersion: ideaIntent.version
    }
  });

  const ingestedSignals = await runSignalIngestionAgent({
    tenantId,
    sources: ideaIntent.sources
  });

  const recentSignals = await prisma.ideaSignal.findMany({
    where: { tenantId },
    orderBy: { createdAt: 'desc' },
    take: 50
  });

  const candidates = await runProblemMapperAgent({
    signals: recentSignals,
    filters: ideaIntent.filters,
    useLLM: false // Set to true when LLM is configured
  });

  const createdIdeas = [];

  for (const candidate of candidates) {
    const existing = await prisma.idea.findFirst({
      where: {
        tenantId,
        title: candidate.title
      }
    });

    if (existing) continue;

    // Auto-score the idea immediately
    const transformation = draftTransformationStatement({
      title: candidate.title,
      description: candidate.description,
      icpDescription: candidate.icpDescription
    } as any);

    const hardFilters = runHardFilters(
      {
        title: candidate.title,
        description: candidate.description,
        icpDescription: candidate.icpDescription,
        arpuEstimate: candidate.arpuEstimate,
        regulatedConcern: false,
        manualWorkHeavy: false,
        founderFitSignal: true
      } as any,
      ideaIntent.filters
    );

    const passesAll = Object.values(hardFilters).every(Boolean);
    let scores = {
      painFrequencyScore: 1,
      agentLeverageScore: 1,
      dataSurfaceScore: 1,
      repeatabilityScore: 1,
      totalScore: 4
    };

    if (passesAll) {
      scores = scoreIdea(
        {
          title: candidate.title,
          description: candidate.description,
          icpDescription: candidate.icpDescription
        } as any,
        ideaIntent.filters
      );
    }

    const initialState =
      !passesAll
        ? 'KILLED'
        : scores.totalScore >= ideaIntent.filters.minScoreForExperiment
          ? 'EXPERIMENTING'
          : 'SCORING';

    const idea = await prisma.idea.create({
      data: {
        tenantId,
        title: candidate.title,
        description: candidate.description,
        icpDescription: candidate.icpDescription,
        arpuEstimate: candidate.arpuEstimate,
        transformation,
        state: initialState,
        autoGenerated: true,
        sourceSignalIds: candidate.sourceSignalIds,
        ...hardFilters,
        ...scores
      }
    });

    createdIdeas.push(idea);

    await logEvent({
      tenantId,
      type: 'IDEA_AUTO_CREATED',
      primaryEntityId: idea.id,
      payload: {
        sourceSignalIds: candidate.sourceSignalIds,
        ideaIntentVersion: ideaIntent.version
      }
    });

    await upsertArchetypeInstance({
      tenantId,
      candidate,
      linkedIdeaId: idea.id,
      intentVersion: ideaIntent.archetypeFramework.version,
      framework: ideaIntent.archetypeFramework.framework
    });
  }

  await logEvent({
    tenantId,
    type: 'FLOW_COMPLETED',
    flowInstanceId,
    payload: {
      flow: 'weeklyDiscoverAndCompress',
      ideaIntentVersion: ideaIntent.version,
      ingestedSignalCount: ingestedSignals.length,
      createdIdeaCount: createdIdeas.length
    }
  });

  return {
    ingestedSignals,
    createdIdeas
  };
}

const TEMPLATE_TO_ARCHETYPE: Record<
  string,
  { patternKey: string; icpKey?: string }
> = {
  'inbox-spend': { patternKey: 'cashflow_guardian', icpKey: 'agencies' },
  'mrr-briefing': { patternKey: 'cashflow_guardian', icpKey: 'solo_saas' },
  'revops-guardian': {
    patternKey: 'revops_signal_watch',
    icpKey: 'seed_ae_teams'
  },
  'support-compressor': {
    patternKey: 'ops_control_panel',
    icpKey: 'ops_heads'
  },
  'partner-copilot': {
    patternKey: 'ops_control_panel',
    icpKey: 'agency_leads'
  }
};

type UpsertArchetypeParams = {
  tenantId: string;
  candidate: Awaited<ReturnType<typeof runProblemMapperAgent>>[number];
  linkedIdeaId: string;
  intentVersion: string;
  framework: ArchetypeFramework;
};

async function upsertArchetypeInstance({
  tenantId,
  candidate,
  linkedIdeaId,
  intentVersion,
  framework
}: UpsertArchetypeParams) {
  const mapping = TEMPLATE_TO_ARCHETYPE[candidate.templateId];
  if (!mapping) return;

  const pattern = framework.patterns.find(
    (entry) => entry.key === mapping.patternKey
  );

  if (!pattern) return;

  const icpOption =
    pattern.icpOptions.find((entry) => entry.key === mapping.icpKey) ??
    pattern.icpOptions[0];

  const instance = await prisma.archetypeInstance.upsert({
    where: {
      tenantId_patternKey_icpKey: {
        tenantId,
        patternKey: pattern.key,
        icpKey: mapping.icpKey ?? 'default'
      }
    },
    update: {
      label: candidate.title,
      summary: candidate.description,
      icpDescription:
        candidate.icpDescription ?? icpOption?.icpDescription ?? undefined,
      dataSurfaces: pattern.dataSurfaces,
      targetArpuLow: candidate.arpuEstimate ?? undefined,
      intentVersion,
      sourceSignalIds: candidate.sourceSignalIds,
      linkedIdeaId
    },
    create: {
      tenantId,
      patternKey: pattern.key,
      icpKey: mapping.icpKey ?? 'default',
      label: candidate.title,
      summary: candidate.description,
      icpDescription:
        candidate.icpDescription ?? icpOption?.icpDescription ?? undefined,
      dataSurfaces: pattern.dataSurfaces,
      targetArpuLow: candidate.arpuEstimate ?? undefined,
      intentVersion,
      sourceSignalIds: candidate.sourceSignalIds,
      linkedIdeaId
    }
  });

  await runArchetypeScorerAgent({
    tenantId,
    archetypeInstanceId: instance.id,
    framework
  });
}
