/**
 * Test Setup and Utilities
 * 
 * Provides common test utilities, database helpers, and cleanup functions
 */

import { PrismaClient } from '@prisma/client';
import 'dotenv/config';
import { prisma as appPrisma } from '../../src/l0/db';

export const TEST_TENANT_ID = 'test-tenant-' + Date.now();

let prisma: PrismaClient | null = null;

export function getTestPrisma(): PrismaClient {
  // Use the app's prisma instance if available, otherwise create new
  if (!prisma) {
    prisma = appPrisma || new PrismaClient();
  }
  return prisma;
}

/**
 * Ensure test tenant exists
 */
export async function ensureTestTenant(tenantId: string = TEST_TENANT_ID) {
  const prisma = getTestPrisma();
  
  const existing = await prisma.tenant.findUnique({
    where: { id: tenantId }
  });
  
  if (!existing) {
    await prisma.tenant.create({
      data: { id: tenantId, name: `Test Tenant ${tenantId}` }
    });
  }
}

/**
 * Clean up test data for a tenant
 */
export async function cleanupTestData(tenantId: string = TEST_TENANT_ID) {
  const prisma = getTestPrisma();
  
  await prisma.ideaExperiment.deleteMany({ where: { tenantId } });
  await prisma.idea.deleteMany({ where: { tenantId } });
  await prisma.ideaSignal.deleteMany({ where: { tenantId } });
  await prisma.event.deleteMany({ where: { tenantId } });
  // Note: We don't delete the tenant itself to avoid foreign key issues
}

/**
 * Create test signal
 */
export async function createTestSignal(
  tenantId: string,
  content: string,
  source: string = 'Test Source'
) {
  const prisma = getTestPrisma();
  return prisma.ideaSignal.create({
    data: {
      tenantId,
      source,
      content
    }
  });
}

/**
 * Create test idea
 */
export async function createTestIdea(
  tenantId: string,
  overrides: any = {}
) {
  const prisma = getTestPrisma();
  return prisma.idea.create({
    data: {
      tenantId,
      title: 'Test Idea',
      description: 'Test description',
      state: 'BACKLOG',
      autoGenerated: false,
      passesMarket: true,
      passesRegulation: true,
      passesAgentFit: true,
      passesFounderFit: true,
      totalScore: 8,
      painFrequencyScore: 2,
      agentLeverageScore: 2,
      dataSurfaceScore: 2,
      repeatabilityScore: 2,
      ...overrides
    }
  });
}

/**
 * Assertion helper for test results
 */
export function assertTestResult(
  name: string,
  condition: boolean,
  error?: string,
  details?: any
): { name: string; passed: boolean; error?: string; details?: any } {
  return {
    name,
    passed: condition,
    error: condition ? undefined : (error || 'Test failed'),
    details
  };
}

/**
 * Close database connection
 */
export async function closeTestDb() {
  if (prisma) {
    await prisma.$disconnect();
    prisma = null;
  }
}

